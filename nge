#!/bin/bash
set -Eeo pipefail
set -o errexit    # Used to exit upon error, avoiding cascading errors

IFS=$'\n\t'

RED="31"
GREEN="32"
YELLOW="33"
BOLDGREEN="\e[1;${GREEN}m"
ITALICRED="\e[3;${RED}m"
BOLDYELLOW="\e[1;${YELLOW}m"
NC="\e[0m"

# read .env file
set -o allexport
source .env set
set +o allexport

# usage: file_env VAR [DEFAULT]
#    ie: file_env 'XYZ_DB_PASSWORD' 'example'
# (will allow for "$XYZ_DB_PASSWORD_FILE" to fill in the value of
#  "$XYZ_DB_PASSWORD" from a file, especially for Docker's secrets feature)
file_env() {
	local var="$1"
	local fileVar="${var}_FILE"
	local def="${2:-}"
	if [ "${!var:-}" ] && [ "${!fileVar:-}" ]; then
		echo >&2 "error: both $var and $fileVar are set (but are exclusive)"
		exit 1
	fi
	local val="$def"
	if [ "${!var:-}" ]; then
		val="${!var}"
	elif [ "${!fileVar:-}" ]; then
		val="$(< "${!fileVar}")"
	fi
	export "$var"="$val"
	unset "$fileVar"
}

install() {
	echo "installing in 5 seconds"
	sleep 5

    echo "pgid : ${DOCKER_PGID}, puid : ${DOCKER_PUID}, user : ${DOCKER_USER}"
    printf "\n\n${YELLOW}[core]${NC} installing package...\n"
    composer install
    printf "\n\n${YELLOW}[core]${NC} run post installation script...\n"
    composer run post-root-package-install
    printf "\n\n${YELLOW}[core]${NC} put application under maintenance...\n"
    if [[ -z "$APP_KEY" ]]; then
        artisan key:generate
    fi
    artisan down
    printf "\n\n${YELLOW}[core]${NC} running database migration and seeders...\n"
    artisan migrate
    printf "\n\n${YELLOW}[core]${NC} upping application\n"
    artisan up

    printf "\n\n${BLUE}[app]${NC} building node packages...\n"
    pnpm install --frozen-lockfile
    pnpm run build

}

compose() {
    file_env 'APP_ENV' 'local'

    if [[ "$APP_ENV" == "local" ]]; then
        printf "${BOLDGREEN}→${NC} run docker compose on ${BOLDGREEN}local environment${NC}\n"
        docker compose -f docker-compose.local.yml $@
    else
        printf "${BOLDYELLOW}→${NC} run docker compose on production ${BOLDYELLOW}environment${NC}\n"
        docker compose $@
    fi
}

composer() {
    file_env 'DOCKER_USER' 'dokar'
    printf "${BOLDGREEN}→${NC} run composer on user : ${DOCKER_USER}\n"
    compose run --rm --user=${DOCKER_USER} core composer $@
}

shell() {
    file_env 'DOCKER_USER' 'dokar'
    printf "${BOLDGREEN}→${NC} run shell on user : ${DOCKER_USER}\n"
    compose run --rm --user=${DOCKER_USER} core bash
}

artisan() {
    file_env 'DOCKER_USER' 'dokar'
    printf "${BOLDGREEN}→${NC} run artisan on user : ${DOCKER_USER}\n"
    compose run --rm --user=${DOCKER_USER} core php artisan $@
}

a() {
  artisan $@
}

pnpm() {
    file_env 'DOCKER_USER' 'dokar'
    echo "${BOLDGREEN}→${NC} run pnpm on user : ${DOCKER_USER}\n"
    compose run --rm --user=${DOCKER_USER} core pnpm $@
}

up() {
    echo "Nge up service $@..."
    compose up -d $@
}

down() {
    echo "Nge down all service..."
    compose down
}

check() {
    compose ps
}

update() {
    git pull
    pnpm run build
    compose restart core horizon scheduler gateway
}

reload() {
    artisan down
    compose restart core horizon scheduler gateway
    artisan up
    compose up -d
}

redis-cli() {
  compose exec redis redis-cli
}

# Check if the function exists (bash specific)
if declare -f "$1" > /dev/null
then
  # call arguments verbatim
  "$@"
else
  # Show a helpful error
  echo "'$1' is not a known function name" >&2
  exit 1
fi
